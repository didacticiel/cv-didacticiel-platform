# apps/users/serializers.py

from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError

User = get_user_model()


class UserRegisterSerializer(serializers.ModelSerializer):
    """
    S√©rialiseur pour l'inscription d'un nouvel utilisateur.
    """
    password = serializers.CharField(
        write_only=True, 
        required=True,
        style={'input_type': 'password'}
    )
    password2 = serializers.CharField(
        write_only=True, 
        required=True,
        style={'input_type': 'password'},
        label='Confirmation du mot de passe'
    )

    class Meta:
        model = User
        fields = ['email', 'first_name', 'last_name', 'password', 'password2']
        extra_kwargs = {
            'first_name': {'required': True},
            'last_name': {'required': True},
        }

    def validate(self, data):
        """
        V√©rifie que les deux mots de passe correspondent et respectent les r√®gles de s√©curit√©.
        """
        # V√©rifier que les deux mots de passe correspondent
        if data['password'] != data['password2']:
            raise serializers.ValidationError({
                'password2': 'Les mots de passe ne correspondent pas.'
            })
        
        # üéØ CORRECTION : Ne pas passer password2 au mod√®le User
        # On cr√©e une copie temporaire sans password2 pour la validation
        user_data = {
            'email': data.get('email'),
            'first_name': data.get('first_name'),
            'last_name': data.get('last_name'),
        }
        
        # Valider le mot de passe selon les r√®gles Django
        try:
            validate_password(data['password'], user=User(**user_data))
        except ValidationError as e:
            raise serializers.ValidationError({'password': list(e.messages)})
        
        return data

    def create(self, validated_data):
        """
        Cr√©e un nouvel utilisateur avec le mot de passe hash√©.
        """
        # üéØ CORRECTION : Retirer password2 avant de cr√©er l'utilisateur
        validated_data.pop('password2')
        
        # Cr√©er l'utilisateur avec create_user qui g√®re automatiquement le hashing
        user = User.objects.create_user(
            email=validated_data['email'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name'],
            password=validated_data['password']
        )
        
        return user


class UserSerializer(serializers.ModelSerializer):
    """
    S√©rialiseur pour afficher et mettre √† jour les informations d'un utilisateur.
    """
    class Meta:
        model = User
        fields = ['id', 'email', 'first_name', 'last_name', 'avatar', 'created_at']
        read_only_fields = ['id', 'email', 'created_at']


class UserAvatarSerializer(serializers.ModelSerializer):
    """
    S√©rialiseur pour la mise √† jour de l'avatar uniquement.
    """
    class Meta:
        model = User
        fields = ['avatar']

#apps/users/serializers.py

from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core import exceptions as django_exceptions
from django.utils.translation import gettext_lazy as _

User = get_user_model()

# =========================================================================
# 1. ENREGISTREMENT (REGISTER)
# =========================================================================

class UserRegisterSerializer(serializers.ModelSerializer):
    """S√©rialiseur pour la cr√©ation d'un nouvel utilisateur."""
    
    # Champ write_only pour la s√©curit√© lors de l'enregistrement
    password = serializers.CharField(write_only=True, required=True, style={'input_type': 'password'})
    password2 = serializers.CharField(write_only=True, required=True, style={'input_type': 'password'})

    class Meta:
        model = User
        fields = (
            'email', 
            'username', 
            'first_name', 
            'last_name', 
            'password', 
            'password2'
        )
        extra_kwargs = {
            'username': {'required': True},
            'first_name': {'required': True},
            'last_name': {'required': True},
        }

    def validate(self, data):
        # Validation de la correspondance des mots de passe
        if data['password'] != data['password2']:
            raise serializers.ValidationError({"password2": _("Les mots de passe ne correspondent pas.")})

        # Validation de la complexit√© du mot de passe
        try:
            validate_password(data['password'], user=User(**data))
        except django_exceptions.ValidationError as e:
            raise serializers.ValidationError({"password": list(e.messages)})
            
        return data

    def create(self, validated_data):
        validated_data.pop('password2')
        # Cr√©ation de l'utilisateur avec son mot de passe hach√©
        user = User.objects.create_user(
            email=validated_data['email'],
            username=validated_data['username'],
            first_name=validated_data['first_name'],
            last_name=validated_data['last_name'],
            password=validated_data['password']
        )
        return user

# =========================================================================
# 2. CONNEXION (LOGIN - bas√© sur email/password)
# =========================================================================

class LoginSerializer(serializers.Serializer):
    """S√©rialiseur pour la connexion (m√©thode non utilis√©e directement par JWT, mais utile)."""
    email = serializers.EmailField(required=True)
    password = serializers.CharField(required=True, write_only=True, style={'input_type': 'password'})

# =========================================================================
# 3. D√âTAILS DU PROFIL (GET/UPDATE /users/me/)
# =========================================================================

class UserSerializer(serializers.ModelSerializer):
    """S√©rialiseur pour la lecture et la mise √† jour du profil utilisateur."""
    
    # Ajout du champ 'avatar' pour la lecture et la mise √† jour
    avatar_url = serializers.ImageField(source='avatar', read_only=True)
    
    class Meta:
        model = User
        fields = (
            'id', 
            'email', 
            'username', 
            'first_name', 
            'last_name', 
            'is_premium_subscriber', 
            'avatar_url', # Le chemin complet de l'image
            'is_staff', 
            'date_joined'
        )
        read_only_fields = ('id', 'email', 'is_premium_subscriber', 'is_staff', 'date_joined')
        
# =========================================================================
# 4. T√âL√âCHARGEMENT D'AVATAR (PATCH /users/me/avatar/)
# =========================================================================

class UserAvatarSerializer(serializers.ModelSerializer):
    """S√©rialiseur pour la mise √† jour du champ avatar uniquement."""
    class Meta:
        model = User
        fields = ('avatar',)        